//
//  Tests.c
//  hadrons EOS
//
//  Created by Clebson Graeff on 2016-08-16.
//  Copyright Â© 2016 Clebson Graeff. All rights reserved.
//

/*
 * RunTests(): A place to run tests.
 *
 *  Purpose:
 *  Running tests is always a good idea, but they tend to clutter
 *  the code. To keep things a bit more neat, all tests should
 *  be put in this function.
 *
 *  Any function may be called from here, as long as the header that
 *  contains the function prototype is included with
 *      #include "the_header.h"
 *  That, however, will exclude functions that are declared in 'main.c'
 *  as that file has no corresponding header. This will exclude the loop
 *  on the run variable and the main products of the calculation. Those
 *  results should be tested by other means (that is, not in this program).
 *
 *  Template:
 *  The tests should be written as follows:
 *  RunTests()
 *  {
 *      #pragma mark A Title (1)
 *      //
 *      // Description (2)
 *      //
 *      if (true) (3)
 *      {
 *          printf("TEST: A Title\n"); (4)
 *
 *          // Set path for and create log file
 *          SetFilePath("tests/a-title/"); (5)
 *          FILE * log_file = OpenFile("run.log");
 *
 *          // Set path for other files
 *          SetFilePath("tests/a-title/data/"); (6)
 *
 *          SetParametersSet("aSet"); (7)
 *
 *          // do stuff (8)
 *
 *          fclose(log_file); (9)
 *
 *          UnsetFilePath(); (10)
 *      }
 *  }
 *  where
 *       (1) Some editor (e.g. Xcode, TextWrangler) make a list of functions
 *           contained in a file. Any '#pragma mark A Title' is listed in that
 *           list as 'A Title'. This makes the navigation through the tests
 *           easier.
 *       (2) A nice description of the purpose of the test is always a good
 *           idea.
 *       (3) The 'if' makes enabling/disabling the test really simple, it's just
 *           a matter of setting the argument of the 'if' to true/false. Also,
 *           the variables declared inside the {} block exist only inside the
 *           block. This prevent the unintended reuse of meaningless values from
 *           other tests.
 *       (4) Output the test being run to the screen. This should be the same
 *           text as the 'A Title' in the '#pragma mark'.
 *       (5) Set the path to a directory specific to the current test and
 *           create a log file. Any information of the test may be saved in
 *           that log.
 *       (6) Set the path to other files generated by the test.
 *       (7) Chooses a parameters set to run the current test.
 *       (8) The test itself should be coded at that point.
 *       (9) Close log file.
 *      (10) Unset the files path. (This is necessary as other parts of the code
 *           may expect it to be the default, which is the dir that contais the
 *           executable file.)
 *
 */

#include <stdbool.h>
#include <strings.h>
#include <stdio.h>
#include <math.h>

#include "CommandlineOptions.h"
#include "Tests.h"
#include "AuxiliaryFunctions.h"
#include "ZeroTemperatureEOS.h"
#include "Constants.h"
#include "Parameters.h"
#include "FiniteTemperatureEOS.h"

void RunTests()
{
#pragma mark Zeroed gap equation
    
    // Write the zeroed gap equation for a set of proton and neutron
    // densities, for the eNJL1 parameters set. This serves for
    // verification purposes, as we should get a characteristic
    // curve. This tests functions used in the zero temperature case.
	if (true)
	{
        printf("TEST: Zeroed gap equation\n");
        
        // Set path for and create log file
        SetFilePath("tests/zeroed-gap-equation/");
        FILE * log_file = OpenFile("run.log");
        
        // Set path for other files
        SetFilePath("tests/zeroed-gap-equation/data/");

        SetParametersSet("eNJL1");
        
        double neutron_density[9] = {0.0125, 0.025, 0.0375, 0.05, 0.0625, 0.075, 0.0875, 0.1, 0.1125};
        double proton_density[9] = {0.0125, 0.025, 0.0375, 0.05, 0.0625, 0.075, 0.0875, 0.1, 0.1125};
        
        double neutron_fermi_momentum[9];
        double proton_fermi_momentum[9];
        
        for (int i = 0; i < 9; i++){
            neutron_fermi_momentum[i] = FermiMomentum(neutron_density[i]);
            proton_fermi_momentum[i] = FermiMomentum(proton_density[i]);
        }
		
        for (int i = 0; i < 9; i++){
            for (int j = 0; j < 9; j++){
            
                double m = 0;
                
                char filename[256];
                sprintf(filename, "gap_dens_%d_%d.dat", i, j);
                
                FILE * f = OpenFile(filename);
                
                gap_equation_input input;
                input.proton_density = proton_density[i];
                input.neutron_density = neutron_density[j];
                input.proton_fermi_momentum = proton_fermi_momentum[i];
                input.neutron_fermi_momentum = neutron_fermi_momentum[j];
                
                while (m < 1000.0) {
                    fprintf(f, "%20.15E\t%20.15E\n", m, GapEquation(m, &input));
                    m += 0.5;
                }
                
                fclose(f);
            }
        }

        fprintf(log_file, "Write the zeroed gap equation for a set of proton and neutron\n"
                          "densities, for the eNJL1 parameters set. This serves for\n"
                          "verification purposes, as we should get a characteristic\n"
                          "curve. This tests functions used in the zero temperature case.\n\n");
        fprintf(log_file, "The following values of densities (and corresponding Fermi momenta)\n"
                          "were used:\n");
        fprintf(log_file, "neutron_density = {0.0125, 0.025, 0.0375, 0.05, 0.0625, 0.075, 0.0875, 0.1, 0.1125};\n"
                          "proton_density = {0.0125, 0.025, 0.0375, 0.05, 0.0625, 0.075, 0.0875, 0.1, 0.1125};\n");
        
        PrintParametersToFile(log_file);
        
		fclose(log_file);
        
        UnsetFilePath();
	}
           
#pragma mark Thermodynamic potential as function of mass
    //
    // Writes the thermodynamic potential as a function
    // of mass. In particular, we are interested in seeing
    // that the minimum value is obtained at mass = nucleon mass.
    // (This is valid for zero temperature and chemical potential
    // [chemical potential == 0 -> barionic density == 0])
    //
    if (true)
    {
        printf("TEST: Thermodynamic potential as function of mass\n");
        // Set path for and create log file
        SetFilePath("tests/thermodynamic-potential-as-func-of-mass/");
        FILE * log_file = OpenFile("run.log");
        
        // Set path for other files
        SetFilePath("tests/thermodynamic-potential-as-func-of-mass/data/");
        
        char *sets[] = {"eNJL1", "eNJL1m", "eNJL1OmegaRho1", "eNJL2", "eNJL2m", "eNJL2OmegaRho1", "eNJL3",
                        "eNJL3SigmaRho1"};
        
        int points_number = 1000;

        double mass_min = 0.1;      // (MeV)
        double mass_max = 3.0E3;    // (MeV)

        double proton_fraction = 0.5;
        double barionic_density = 0.0; // (MeV) // Should be zero

        gsl_vector * mass_vector = gsl_vector_alloc(points_number);
        gsl_vector * potential_vector = gsl_vector_alloc(points_number);

        double mass_step = (mass_max - mass_min) / (points_number - 1);

        double proton_density = proton_fraction * barionic_density;
        double neutron_density = (1.0 - proton_fraction) * barionic_density;

        double proton_fermi_momentum = FermiMomentum(proton_density);
        double neutron_fermi_momentum = FermiMomentum(neutron_density);


        for (int set = 0; set < 8; set++){
            
            SetParametersSet(sets[set]);

            double mass = mass_min;

            for (int i = 0; i < points_number; i++){

                double kinectic_energy_density = KinecticEnergyDensity(mass,
                                                                       proton_fermi_momentum,
                                                                       neutron_fermi_momentum);

                double scalar_density = ScalarDensity(mass, proton_fermi_momentum, parameters.theory.cutoff)
                                        + ScalarDensity(mass, neutron_fermi_momentum, parameters.theory.cutoff);

                // If barionic density == 0, the chemical
                // potential functions must return zero.
                double proton_chemical_potential = ProtonChemicalPotential(proton_fermi_momentum,
                                                                           scalar_density,
                                                                           mass,
                                                                           barionic_density,
                                                                           proton_density,
                                                                           neutron_density);

                double neutron_chemical_potential = NeutronChemicalPotential(neutron_fermi_momentum,
                                                                             scalar_density,
                                                                             mass,
                                                                             barionic_density,
                                                                             proton_density,
                                                                             neutron_density);

                double potential = ThermodynamicPotential(scalar_density,
                                                          barionic_density,
                                                          proton_density,
                                                          neutron_density,
                                                          proton_chemical_potential,
                                                          neutron_chemical_potential,
                                                          kinectic_energy_density);

                gsl_vector_set(mass_vector, i, mass);
                gsl_vector_set(potential_vector, i, potential);

                mass += mass_step;
            }

            char filename[256];
            sprintf(filename, "thermodynamic_potential_by_mass-%s.dat", sets[set]);
            
            WriteVectorsToFile(filename,
                               "# mass (MeV), thermodynamic potential (MeV)\n",
                               2,
                               mass_vector,
                               potential_vector);
        }
        
        fprintf(log_file,
                "The thermodynamic potential as a function\n"
                "of mass. In particular, we are interested in seeing\n"
                "that the minimum value is obtained at mass = nucleon mass.\n"
                "(This is valid for zero temperature and chemical potential"
                "[chemical potential == 0 -> barionic density == 0])\n");
        
        PrintParametersToFile(log_file);
        
        fclose(log_file);
        
        UnsetFilePath();
    }
    
#pragma mark Maps of Mass and Renormalized Chemical Potentials Zeroed Equations
    
    // Calculates zeroed gap and barionic densities equations so we can see them
    // and have an insight of what's going on
    if (true)
    {
        printf("TEST: Maps of Mass and Renormalized Chemical Potentials Zeroed Equations\n");
        
        // Set path for and create log file
        SetFilePath("tests/maps/");
        FILE * log_file = OpenFile("run.log");
        
        // Set path for other files
        SetFilePath("tests/maps/data/");
        
        SetParametersSet("eNJL1");
        
        const int num_densities = 1;
        const int num_temperatures = 1;
        
        const double proton_fraction = 0.5;
        
        const double barionic_density[10] = {0.1, 0.08, 0.12, 0.16, 0.2, 0.24, 0.28, 0.32, 0.4, 0.44};
        const double temperature[10] = {10.0, 3.0, 7.0, 10.0, 15.0, 20.0, 25.0, 30.0, 40.0, 50.0};
        
        int mass_n_pts = 400;
        int proton_renorm_chem_pot_n_pts = 400;
        int neutron_renorm_chem_pot_n_pts = 400;
        
        double min_mass = 0.0;
        double max_mass = 1400.0;
        double min_proton_renormalized_chemical_potential = 0.0;
        double max_proton_renormalized_chemical_potential = 1400.0;
        double min_neutron_renormalized_chemical_potential = 0.0;
        double max_neutron_renormalized_chemical_potential = 1400.0;
        
        double mass_step = (max_mass - min_mass) / (double)(mass_n_pts - 1);
        double proton_renorm_chem_pot_step = (max_proton_renormalized_chemical_potential
                                              - min_proton_renormalized_chemical_potential)
                                             / (double)(proton_renorm_chem_pot_n_pts - 1);
        double neutron_renorm_chem_pot_step = (max_neutron_renormalized_chemical_potential
                                               - min_neutron_renormalized_chemical_potential)
                                              / (double)(neutron_renorm_chem_pot_n_pts - 1);
        
        double tolerance_dens_p = 0.005;
        double tolerance_dens_n = 0.005;
        double tolerance_gap = 1.0;
        
        for (int i = 0; i < num_temperatures; i++){ // Temperature
            
            parameters.temperature = temperature[i];
            
            for (int j = 0; j < num_densities; j++){
                
                double proton_barionic_density = proton_fraction * barionic_density[j];
                double neutron_barionic_density = (1.0 - proton_fraction) * barionic_density[j];
                
                char filename[256];
                sprintf(filename, "map_gap_T_%d_d_%d.dat", i, j);
                FILE * zeroed_gap_file = OpenFile(filename);
                
                sprintf(filename, "map_dp_gap_T_%d_d_%d.dat", i, j);
                FILE * zeroed_dp_gap_file = OpenFile(filename);
                
                sprintf(filename, "map_dn_gap_T_%d_d_%d.dat", i, j);
                FILE * zeroed_dn_gap_file = OpenFile(filename);
                
                double mass = 0;
                for (int k = 0; k < mass_n_pts; k++){
                    
                    double proton_renorm_chem_pot = 0;
                    for (int l = 0; l < proton_renorm_chem_pot_n_pts; l++){
                        
                        double progress = (k * mass_n_pts + l) / (double)(mass_n_pts * proton_renorm_chem_pot_n_pts);
                        
                        printf("\t[T = %f, bar_dens = %f] %4.1f%%\r", temperature[i], barionic_density[j], progress * 100);
                        fflush(stdout);

                        double neutron_renorm_chem_pot = 0;
                        for (int m = 0; m < neutron_renorm_chem_pot_n_pts; m++){
                            
                            double proton_scalar_density = ScalarDensityAtFiniteTemperature(mass,
                                                                                            proton_renorm_chem_pot,
                                                                                            parameters.theory.cutoff);
                            double neutron_scalar_density = ScalarDensityAtFiniteTemperature(mass,
                                                                                             neutron_renorm_chem_pot,
                                                                                             parameters.theory.cutoff);
                            double gap = fabs(ZeroedGapFunction(mass,
                                                                proton_scalar_density,
                                                                neutron_scalar_density,
                                                                proton_barionic_density,
                                                                neutron_barionic_density));
                            //printf("gap: %f\n", gap);
                            
                            if (gap < tolerance_gap)
                                fprintf(zeroed_gap_file,
                                        "%f\t%f\t%f\n",
                                        mass,
                                        proton_renorm_chem_pot,
                                        neutron_renorm_chem_pot);
                            
                            if (fabs(ZeroedDensFunction(mass, proton_barionic_density, proton_renorm_chem_pot)) < tolerance_dens_p)
                                fprintf(zeroed_dp_gap_file,
                                        "%f\t%f\t%f\n",
                                        mass,
                                        proton_renorm_chem_pot,
                                        neutron_renorm_chem_pot);
                            
                            if (fabs(ZeroedDensFunction(mass, neutron_barionic_density, neutron_renorm_chem_pot)) < tolerance_dens_n)
                                fprintf(zeroed_dn_gap_file,
                                        "%f\t%f\t%f\n",
                                        mass,
                                        proton_renorm_chem_pot,
                                        neutron_renorm_chem_pot);
                                
                            neutron_renorm_chem_pot += neutron_renorm_chem_pot_step;
                        }
                        
                        proton_renorm_chem_pot += proton_renorm_chem_pot_step;
                    }
                    
                    mass += mass_step;
                }

                fclose(zeroed_gap_file);
                fclose(zeroed_dp_gap_file);
                fclose(zeroed_dn_gap_file);
            }
        }
        printf("\n");
        
        fprintf(log_file,
                "Calculates zeroed gap and barionic densities equations so we can see them\n"
                "and have an insight of what's going on.\n");
        PrintParametersToFile(log_file);
        
        fclose(log_file);
        
       UnsetFilePath();
    }

}
